name: Concatenate Audio Chunks and Upload to Cloudinary

on:
  push:
    paths:
      - "public/data/uploads/*.json"

jobs:
  concat-upload:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Read upload info JSON
        id: uploadinfo
        run: |
          # Try to get the latest added/modified JSON file in uploads
          json_file=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep 'public/data/uploads/' | tail -n1)
          # Fallback: list the most recent file if above fails
          if [ -z "$json_file" ]; then
            json_file=$(ls -t public/data/uploads/*.json | head -n1)
          fi
          if [ ! -f "$json_file" ]; then
            echo "No upload info JSON file found. Exiting."
            exit 1
          fi
          echo "JSON_FILE=$json_file" >> $GITHUB_ENV
          cat "$json_file"
          uploadId=$(jq -r .uploadId "$json_file")
          totalChunks=$(jq -r .totalChunks "$json_file")
          extension=$(jq -r .fileExtension "$json_file")
          if [ -z "$extension" ] || [ "$extension" = "null" ]; then
            echo "Extension is missing or null in $json_file. Exiting."
            exit 1
          fi
          echo "UPLOAD_ID=$uploadId" >> $GITHUB_ENV
          echo "TOTAL_CHUNKS=$totalChunks" >> $GITHUB_ENV
          echo "EXTENSION=$extension" >> $GITHUB_ENV

      - name: Download audio chunks from Cloudinary
        run: |
          for i in $(seq -w 0 $(($TOTAL_CHUNKS - 1))); do
            curl -L -o chunk-$i.$EXTENSION "https://res.cloudinary.com/${{ secrets.CLOUDINARY_CLOUD_NAME }}/raw/upload/podcast/chunks/$UPLOAD_ID-chunk-$i.$EXTENSION"
          done

      - name: Install FFmpeg
        run: sudo apt-get update && sudo apt-get install -y ffmpeg

      - name: Concatenate with FFmpeg
        run: |
          for f in chunk-*.$EXTENSION; do echo "file '$PWD/$f'"; done > chunks.txt
          ffmpeg -f concat -safe 0 -i chunks.txt -c copy output.$EXTENSION

      - name: Upload concatenated file to Cloudinary
        env:
          CLOUDINARY_CLOUD_NAME: ${{ secrets.CLOUDINARY_CLOUD_NAME }}
          CLOUDINARY_API_KEY: ${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET: ${{ secrets.CLOUDINARY_API_SECRET }}
        run: |
          pip install cloudinary
          python -c "import cloudinary; import cloudinary.uploader; cloudinary.config(cloud_name='${{ secrets.CLOUDINARY_CLOUD_NAME }}', api_key='${{ secrets.CLOUDINARY_API_KEY }}', api_secret='${{ secrets.CLOUDINARY_API_SECRET }}'); result = cloudinary.uploader.upload('output.$EXTENSION', resource_type='raw', public_id=f'podcast/final/{os.environ[\'UPLOAD_ID\']}'); print(result)"

      - name: Update playlists.json with processingStatus
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pip install jq
          PLAYLISTS_FILE="public/data/playlists.json"
          # Extract playlistId and episodeId from upload info JSON
          playlistId=$(jq -r .playlistId "$JSON_FILE")
          episodeId=$(jq -r .episodeId "$JSON_FILE")
          # Get Cloudinary URL (from previous upload step output or reconstruct)
          audioUrl="https://res.cloudinary.com/${{ secrets.CLOUDINARY_CLOUD_NAME }}/raw/upload/podcast/final/$UPLOAD_ID.$EXTENSION"
          # Update processingStatus and audioUrl in playlists.json
          tmpfile=$(mktemp)
          jq --arg pid "$playlistId" --arg eid "$episodeId" --arg url "$audioUrl" \
            '(.[] | select(.id == $pid).episodes[] | select(.id == $eid)) |= (.processingStatus = "complete" | .audioUrl = $url)' \
            "$PLAYLISTS_FILE" > "$tmpfile" && mv "$tmpfile" "$PLAYLISTS_FILE"
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add "$PLAYLISTS_FILE"
          git commit -m "Mark episode $episodeId as complete in playlist $playlistId [skip ci]"
          git push

      - name: Cleanup
        run: rm -f chunk-*.$EXTENSION chunks.txt output.$EXTENSION
