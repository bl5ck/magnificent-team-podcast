name: Concatenate Audio Chunks and Upload to Cloudinary

on:
  push:
    paths:
      - "public/data/uploads/*.json"

jobs:
  concat-upload:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Read upload info JSON
        id: uploadinfo
        run: |
          # Try to get the latest added/modified JSON file in uploads
          json_file=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep 'public/data/uploads/' | tail -n1)
          # Fallback: list the most recent file if above fails
          if [ -z "$json_file" ]; then
            json_file=$(ls -t public/data/uploads/*.json | head -n1)
          fi
          if [ ! -f "$json_file" ]; then
            echo "No upload info JSON file found. Exiting."
            exit 1
          fi
          echo "JSON_FILE=$json_file" >> $GITHUB_ENV
          cat "$json_file"
          uploadId=$(jq -r .uploadId "$json_file")
          totalChunks=$(jq -r .totalChunks "$json_file")
          extension=$(jq -r .fileExtension "$json_file")
          if [ -z "$extension" ] || [ "$extension" = "null" ]; then
            echo "Extension is missing or null in $json_file. Exiting."
            exit 1
          fi
          echo "UPLOAD_ID=$uploadId" >> $GITHUB_ENV
          echo "TOTAL_CHUNKS=$totalChunks" >> $GITHUB_ENV
          echo "EXTENSION=$extension" >> $GITHUB_ENV

      - name: Download audio chunks from Cloudinary
        run: |
          for i in $(seq -f "%04g" 0 $(($TOTAL_CHUNKS - 1))); do
            curl -L -o chunk-$i.$EXTENSION "https://res.cloudinary.com/${{ secrets.CLOUDINARY_CLOUD_NAME }}/raw/upload/podcast/chunks/$UPLOAD_ID-chunk-$i.$EXTENSION"
          done

      - name: List and verify chunk files
        run: |
          ls -lh chunk-*.$EXTENSION || echo "No chunks downloaded"
          for f in chunk-*.$EXTENSION; do
            if [ ! -s "$f" ]; then
              echo "Chunk $f is missing or empty!";
              exit 1;
            fi
          done
          echo "All chunk files are present and non-empty."

      - name: Install FFmpeg
        run: sudo apt-get update && sudo apt-get install -y ffmpeg

      - name: Concatenate with FFmpeg
        run: |
          for i in $(seq -f "%04g" 0 $(($TOTAL_CHUNKS - 1))); do
            echo "file '$PWD/chunk-$i.$EXTENSION'"
          done > chunks.txt
          ffmpeg -f concat -safe 0 -i chunks.txt -c copy output.$EXTENSION

      - name: Upload concatenated file to Cloudinary
        env:
          CLOUDINARY_CLOUD_NAME: ${{ secrets.CLOUDINARY_CLOUD_NAME }}
          CLOUDINARY_API_KEY: ${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET: ${{ secrets.CLOUDINARY_API_SECRET }}
        run: |
          pip install cloudinary
          python -c "import cloudinary; import cloudinary.uploader; cloudinary.config(cloud_name='${{ secrets.CLOUDINARY_CLOUD_NAME }}', api_key='${{ secrets.CLOUDINARY_API_KEY }}', api_secret='${{ secrets.CLOUDINARY_API_SECRET }}'); result = cloudinary.uploader.upload('output.${EXTENSION}', resource_type='raw', public_id='podcast/final/${UPLOAD_ID}'); print(result)"

      - name: Update playlists.json with processingStatus
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pip install jq
          # Download the latest playlists.json from the main branch if not present
          PLAYLISTS_FILE="public/data/playlists.json"
          if [ ! -f "$PLAYLISTS_FILE" ]; then
            mkdir -p public/data
            curl -L -o "$PLAYLISTS_FILE" "https://raw.githubusercontent.com/bl5ck/magnificent-team-podcast/main/playlists.json"
          fi
          if [ ! -f "$PLAYLISTS_FILE" ]; then
            echo "Error: $PLAYLISTS_FILE does not exist and could not be downloaded."
            exit 1
          fi
          # Extract playlistId and episodeId from upload info JSON
          playlistId=$(jq -r .playlistId "$JSON_FILE")
          episodeId=$(jq -r .episodeId "$JSON_FILE")
          # Get Cloudinary URL (from previous upload step output or reconstruct)
          audioUrl="https://res.cloudinary.com/${{ secrets.CLOUDINARY_CLOUD_NAME }}/raw/upload/podcast/final/$UPLOAD_ID.$EXTENSION"
          # Update processingStatus and audioUrl in playlists.json
          tmpfile=$(mktemp)
          jq --arg pid "$playlistId" --arg eid "$episodeId" --arg url "$audioUrl" \
            '(.[] | select(.id == $pid).episodes[] | select(.id == $eid)) |= (.processingStatus = "complete" | .audioUrl = $url)' \
            "$PLAYLISTS_FILE" > "$tmpfile" && mv "$tmpfile" "$PLAYLISTS_FILE"
          # Commit and upload playlists.json to GitHub via API (same as finalize-upload)
          contentBase64=$(base64 -w 0 "$PLAYLISTS_FILE")
          api_url="https://api.github.com/repos/bl5ck/magnificent-team-podcast/contents/public/data/playlists.json"
          # Get current file SHA if file exists
          fileSha=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" "$api_url" | jq -r .sha)
          payload="{\"message\": \"Update playlists.json with processing status [skip ci]\", \"content\": \"$contentBase64\""
          if [ "$fileSha" != "null" ] && [ -n "$fileSha" ]; then
            payload="$payload, \"sha\": \"$fileSha\""
          fi
          payload="$payload}"
          curl -X PUT -H "Authorization: Bearer $GITHUB_TOKEN" -H "Content-Type: application/json" -d "$payload" "$api_url"

      - name: Cleanup
        run: rm -f chunk-*.$EXTENSION chunks.txt output.$EXTENSION
